package com.joshuasalcedo.development.dependency;

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;

import org.json.JSONArray;
import org.json.JSONObject;

/**
 * Service for checking security vulnerabilities in dependencies
 * This uses the OSS Index API from Sonatype
 */
public class SecurityVulnerabilityService {
    private static final String OSS_INDEX_API = "https://ossindex.sonatype.org/api/v3/component-report";
    private static final HttpClient HTTP_CLIENT = HttpClient.newHttpClient();

    /**
     * Check a dependency for security vulnerabilities
     *
     * @param dependency The dependency to check
     * @return The dependency with security information populated
     */
    public CompletableFuture<Dependency> checkVulnerabilities(Dependency dependency) {
        // Create the Maven coordinates in OSS Index format
        String coordinates = "pkg:maven/" + dependency.getGroupId() + "/" +
                dependency.getArtifactId() + "@" + dependency.getVersion();

        // Create the request body
        JSONObject requestBody = new JSONObject();
        JSONArray coordinates_array = new JSONArray();
        coordinates_array.put(coordinates);
        requestBody.put("coordinates", coordinates_array);

        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(OSS_INDEX_API))
                .header("Content-Type", "application/json")
                .POST(HttpRequest.BodyPublishers.ofString(requestBody.toString()))
                .build();

        return HTTP_CLIENT.sendAsync(request, HttpResponse.BodyHandlers.ofString())
                .thenApply(response -> {
                    if (response.statusCode() == 200) {
                        try {
                            JSONArray results = new JSONArray(response.body());
                            if (results.length() > 0) {
                                JSONObject result = results.getJSONObject(0);
                                JSONArray vulnerabilities = result.optJSONArray("vulnerabilities");

                                if (vulnerabilities != null && vulnerabilities.length() > 0) {
                                    // Build the security issue details
                                    StringBuilder details = new StringBuilder();
                                    details.append("Found ").append(vulnerabilities.length())
                                            .append(" vulnerabilities:\n");

                                    for (int i = 0; i < vulnerabilities.length(); i++) {
                                        JSONObject vuln = vulnerabilities.getJSONObject(i);
                                        details.append(" - ")
                                                .append(vuln.optString("title", "Unknown vulnerability"))
                                                .append(" (CVSS: ")
                                                .append(vuln.optDouble("cvssScore", 0.0))
                                                .append(")\n");
                                    }

                                    dependency.setSecurityIssueDetails(details.toString());
                                    dependency.setHasSecurityIssues(true);
                                }
                            }
                        } catch (Exception e) {
                            // Handle JSON parsing errors
                            System.err.println("Error parsing security information: " + e.getMessage());
                        }
                    }
                    return dependency;
                });
    }

    /**
     * Check a list of dependencies for security vulnerabilities
     *
     * @param dependencies The dependencies to check
     * @return The dependencies with security information populated
     */
    public CompletableFuture<List<Dependency>> checkVulnerabilities(List<Dependency> dependencies) {
        List<CompletableFuture<Dependency>> futures = new ArrayList<>();

        for (Dependency dependency : dependencies) {
            futures.add(checkVulnerabilities(dependency));
        }

        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
                .thenApply(v -> {
                    List<Dependency> result = new ArrayList<>();
                    for (CompletableFuture<Dependency> future : futures) {
                        result.add(future.join());
                    }
                    return result;
                });
    }
}